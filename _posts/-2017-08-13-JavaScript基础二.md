---
layout:     post
title:      JavaScript基础二
date:       2017-08-13
author:     Jeamn
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - JavaScript
---

## 一、JavaScript内存机制————数据是如何存储的？
基本数据类型用栈存储，引用数据类型和闭包用堆存储。

## 二、如何理解EventLoop————宏任务和微任务篇
在 JS 中，常见的任务有，
- 1、渲染事件
- 2、用户交互事件
- 3、js脚本执行
- 4、网络请求、文件读写事件

为了让这些任务有条不紊地执行，V8 采用了队列的方式来存储这些任务，即先来的先执行。   

普通任务队列和延迟队列中的任务，都属于宏任务。   

对于每个宏任务，其内部都有一个微任务队列。

引入微任务的初衷是为了解决异步回调的问题，对于异步回调的处理，总结起来有两种方式：  
（1）将异步回调，进行宏任务队列的入队操作；  
（2）将异步回调放到当前宏任务的末尾；

第一种执行回调的时机应该是在前面所有宏任务完成之后，若现在的任务队列非常长，回调得不到执行，会造成卡顿；  
第二种则是，在每一个宏中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空直接执行下一个宏任务，如果不为空，依次执行微任务，直到执行完才去执行下一个宏任务。

常见的微任务有：MutationObserver、Promise.then（或.reject）以及以 Promise 为基础开发的其他技术（如fetch API），还包括 V8 的垃圾回收过程。

## 、如三何理解EventLoop————node.js篇
### 1、nodejs 的 eventLoop 分为五个阶段：
（1）timer 阶段：执行定时器回调的阶段。会检查定时器（setTimeout、setInterval），如果到了时间，就执行回调。   
（2）I/O 异常回调阶段：第一阶段结束后，当没有等待到的异步事件的响应时，nodejs 会进入到 I/O 异常的回调阶段。比如 TCP 连接遇到拒绝，就会在这个时候执行回调。   
（3）poll 阶段：当 nodejs 中有异步操作，比如文件 I/O、网络 I/O 等操作做完了，就会通过 'data'、'connect' 等事件使得事件循环到达 poll 阶段。到达 poll 阶段后，如果当前已经存在定时器且到时间了，拿出来执行，eventLoop 将回到 timer 阶段；如果没有定时器，会去看回调函数队列。如果队列不为空，拿出队列中的方法依次执行；如果队列为空，检查是否有 setImmdiate 的回调。有则前往 check 极端；没有则继续等待（相当于阻塞一段时间），等待 callback 函数加入队列，加入后会立即执行。一段时间后，会自动进入 check 阶段。   
（4）check 阶段：直接执行 setImmdiate 的回调。   
（5）关闭事件的回调阶段

### 2、node 版本影响执行结果：
node 版本 >= 11的，它会和浏览器表现一致，一个定时器运行完立即执行响应的微任务。   
小于11的情况下，对定时器的处理是：若一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么会将微任务暂时保存直接去执行新的定时器任务，执行完后，再一一执行中途产生的微任务。

### 3、nodejs 和 浏览器关于eventLoop的主要区别
浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段执行的。

### 4、关于 process.nextTick 的一点说明
process.nextTick 是一个独立于 eventLoop 的任务队列，在每一个 eventLoop 阶段完成后悔去检查这个队列，如果有任务，会让这部分任务 `优先于微任务` 执行。

