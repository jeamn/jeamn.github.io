---
layout:     post
title:      JavaScript基础二
date:       2017-08-13
author:     Jeamn
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - JavaScript
---

## 一、理解 JavaScript 中的执行上下文和执行栈
执行上下文：    
是当前 js 代码被解析和执行时所在环境的抽象概念。它定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

执行上下文三种类型：   
（1）全局执行上下文：一个，浏览器中是 window，this 指向这个全局对象；   
（2）函数执行上下文：无数个，只有在函数被调用的时候才会创建，每次调用都会创建一个新的执行上下文；   
（3）Eval 函数执行上下文：运行在 eval 函数中的代码。

执行栈也叫调用栈，具有后进先出结构，用于存储在代码执行期间创建的所有执行上下文。

首次运行 js 代码时，会创建一个全局执行上下文并 push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 push 到当前执行栈的栈顶。

运行完函数后，该函数执行上下文会从栈中 pop 出，上下文控制权将移到当前执行栈的下一个执行上下文。

### 执行上下文的创建分两个阶段：  
（1）创建阶段：   
> 确定 this 的值，也称为 This Binding    
> 词法环境组件被创建    
> 变量环境组件被创建    
（2）执行阶段：完成对所有变量的分配，最后执行代码

### This Binding：   
> 全局执行上下文中，this 的值指向全局对象，在浏览器中指向 window 对象，在 nodejs 中指向这个文件的 module 对象。
> 函数执行上下文中，this 的值取决于函数的调用方式，具体有：默认绑定、隐式绑定、显示绑定、new绑定、箭头函数

### 词法环境两个组成部分：   
（1）环境记录：存储变量和函数声明的实际位置    
（2）对外部环境的引用：可以访问其外部词法环境

### 词法环境两种类型：    
（1）全局环境：是一个没有外部环境的词法环境，其外部引用为 null。拥有一个全局对象（window）及其关联的方法和属性（如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。    
（2）函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。   

### 变量环境
变量环境也是一种词法环境，因此具有词法环境的所有属性。    
在 ES6 中，词法环境用于存储 `函数声明和变量（let、const）绑定`，变量环境用于存储 `变量（var）绑定`。

### 变量提升原因
在执行上下文创建阶段，函数声明存储在环境中，而 var 定义的变量会被设置为 undefined 。



## 二、四种常见的内存泄漏
### 1、意外的全局变量
函数内部未用 var 定义变量，或者函数内部使用了 this 赋值了变量。    
解决方法：在 js 文件头部加上 'use strict'，使用严格模式避免意外的全局变量，此时 this 会指向 undefined。

### 2、被遗忘的计时器或回调函数
未结束的定时器未赋值为 null

### 3、闭包

## 三、闭包
### 1、概念
闭包是指有权限访问另外一个函数作用域中的变量的函数。

当函数返回没有被引用的时候，就会被垃圾回收器回收。但是对于闭包，即使外部函数返回了，函数对象仍会引用它被创建时的作用域对象。

### 2、闭包特性
（1）可以访问当前函数以外的变量  
```js
function fa(){
    var a = 1
    function fb(){
        console.log(a)
    }
    return fb()
}
fa()
```

（2）即使外部函数已经返回，闭包仍能访问外部函数定义的变量
```js
function fa(){
    var a = 1
    function fb(){
        console.log(a)
    }
    return fb
}
let fc = fa()
fc()
```

（3）闭包可以更新外部变量的值
```js
function fa(){
    var a = 1
    function fb(){
        a = 2
        console.log(a)
    }
    return fb
}
let fc = fa()
fc()
```

### 3、作用域链和原型链
作用域链：当访问一个变量时，解释器会首先在当前作用域查找标识符，如果没找到会去父作用域找，直到找到该变量的标识符或者不在父作用域中，这就是作用域链。   

原型链：在 JavaScript 中，一共有两种类型的值，原始值和对象值。每个对象都有一个内部属性[[prototype]]，我们通常称之为原型。原型的值可以是一个对象，也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，称之为原型链（比如我们新建一个数组，数组的方法就是从数组的原型上继承而来的）。

两者区别：   
一般来说，作用域链是针对变量的，js里面大的范围上来说，只有两种作用域，全局作用域和函数内部作用域，如果函数1里面又定义了函数2（一般都是匿名函数）， 那么就有了这么一个作用域链全局作用域==>函数1作用域==>函数2作用域；特点是函数1里面可以直接使用全局作用域的变量，函数2里面可以直接使用全局作用域和函数1作用域的变量。    
而原型链的话，一般是定义构造函数时用到。可以认为是针对构造函数的或者说针对构造函数对应的类的。原型链的头部就是Object类/构造函数，如果有构造函数1.prototype = 构造函数2；那么也就有这么一个原型链； Object ==> 构造函数1 ==> 构造函数2，这样的好处是构造函数2对应的类，可以拥有构造函数1 和Object中的属性，js没有对应继承的关键字，所以用原型链来模拟继承的效果。

两者在查找时的区别：    
如果去查找一个普通对象的属性，但是在当前对象和原型上都找不到时，会返回 undefined，    
```js
function Animal(name){
    this.name = name;
}
Animal.prototype.name = 'mike'
function Dog(dogName){
    this.dogName = dogName;
}
//继承
Dog.prototype = Object.create(Animal.prototype);
var dog1 = new Dog('泰迪');
console.log(dog1.name1)
```

但查找的属性在作用域链中不存在的话就会抛出 ReferenceError。

作用域链的顶端是全局对象，在全局环境中定义的变量会绑定到全局对象中。    
原型链的顶端是 null。

### 4、闭包与作用域链
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope(); // foo指向函数f
foo();					// 调用函数f()
```

执行过程如下：
1、进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；    
2、全局执行上下文初始化；     
3、执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈；    
4、checkscope 执行上下文初始化，创建变量对象、作用域链、this 等；    
5、checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出；    
6、执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；    
7、f 执行上下文初始化，创建变量对象、作用域链、this 等；    
8、f 函数执行完毕，f 函数执行上下文从执行上下文栈中弹出；

当函数 f 执行的时候，checkscope 函数的执行上下文已经被销毁，那么函数 f 是如何获取到 scope 变量的？

解释：函数 f 执行上下文维护了一个作用域链，会指向 checkscope 的作用域，作用域链是一个数组，子函数会保存它所有的父级作用域，指向关系为：当前作用域 -> 父作用域 -> 祖父作用域 -> ··· -> 全局作用域。所以 f 函数维护着 checkscope 的作用域，才能访问到变量 scope。

这就是闭包实现的关键：通过函数的作用域链找到自由变量。

总结：从理论上，所有的函数都是闭包，因为他们都在创建的时候就将上层执行上下文的数据保存起来了。普通函数在访问全局变量就相当于是在访问自由变量。而从实践的角度，以下函数才算是闭包：即使创建函数的上下文已经销毁，它仍然存在（比如内部函数从父函数中返回）；或者在代码中引用了自由变量。