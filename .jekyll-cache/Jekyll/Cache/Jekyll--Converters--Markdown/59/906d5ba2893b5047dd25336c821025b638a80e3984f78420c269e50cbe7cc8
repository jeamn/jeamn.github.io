I"[<h2 id="一javascript内存机制数据是如何存储的">一、JavaScript内存机制————数据是如何存储的？</h2>
<p>基本数据类型用栈存储，引用数据类型和闭包用堆存储。</p>

<h2 id="二如何理解eventloop宏任务和微任务篇">二、如何理解EventLoop————宏任务和微任务篇</h2>
<p>在 JS 中，常见的任务有，</p>
<ul>
  <li>1、渲染事件</li>
  <li>2、用户交互事件</li>
  <li>3、js脚本执行</li>
  <li>4、网络请求、文件读写事件</li>
</ul>

<p>为了让这些任务有条不紊地执行，V8 采用了队列的方式来存储这些任务，即先来的先执行。</p>

<p>普通任务队列和延迟队列中的任务，都属于宏任务。</p>

<p>对于每个宏任务，其内部都有一个微任务队列。</p>

<p>引入微任务的初衷是为了解决异步回调的问题，对于异步回调的处理，总结起来有两种方式：<br />
（1）将异步回调，进行宏任务队列的入队操作；<br />
（2）将异步回调放到当前宏任务的末尾；</p>

<p>第一种执行回调的时机应该是在前面所有宏任务完成之后，若现在的任务队列非常长，回调得不到执行，会造成卡顿；<br />
第二种则是，在每一个宏中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空直接执行下一个宏任务，如果不为空，依次执行微任务，直到执行完才去执行下一个宏任务。</p>

<p>常见的微任务有：MutationObserver、Promise.then（或.reject）以及以 Promise 为基础开发的其他技术（如fetch API），还包括 V8 的垃圾回收过程。</p>

<h2 id="如三何理解eventloopnodejs篇">、如三何理解EventLoop————node.js篇</h2>
<h3 id="1nodejs-的-eventloop-分为五个阶段">1、nodejs 的 eventLoop 分为五个阶段：</h3>
<p>（1）timer 阶段：执行定时器回调的阶段。会检查定时器（setTimeout、setInterval），如果到了时间，就执行回调。 <br />
（2）I/O 异常回调阶段：第一阶段结束后，当没有等待到的异步事件的响应时，nodejs 会进入到 I/O 异常的回调阶段。比如 TCP 连接遇到拒绝，就会在这个时候执行回调。 <br />
（3）poll 阶段：当 nodejs 中有异步操作，比如文件 I/O、网络 I/O 等操作做完了，就会通过 ‘data’、’connect’ 等事件使得事件循环到达 poll 阶段。到达 poll 阶段后，如果当前已经存在定时器且到时间了，拿出来执行，eventLoop 将回到 timer 阶段；如果没有定时器，会去看回调函数队列。如果队列不为空，拿出队列中的方法依次执行；如果队列为空，检查是否有 setImmdiate 的回调。有则前往 check 极端；没有则继续等待（相当于阻塞一段时间），等待 callback 函数加入队列，加入后会立即执行。一段时间后，会自动进入 check 阶段。 <br />
（4）check 阶段：直接执行 setImmdiate 的回调。 <br />
（5）关闭事件的回调阶段</p>

<h3 id="2node-版本影响执行结果">2、node 版本影响执行结果：</h3>
<p>node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即执行响应的微任务。 <br />
小于11的情况下，对定时器的处理是：若一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么会将微任务暂时保存直接去执行新的定时器任务，执行完后，再一一执行中途产生的微任务。</p>

<h3 id="3nodejs-和-浏览器关于eventloop的主要区别">3、nodejs 和 浏览器关于eventLoop的主要区别</h3>
<p>浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段执行的。</p>

<h3 id="4关于-processnexttick-的一点说明">4、关于 process.nextTick 的一点说明</h3>
<p>process.nextTick 是一个独立于 eventLoop 的任务队列，在每一个 eventLoop 阶段完成后悔去检查这个队列，如果有任务，会让这部分任务 <code class="highlighter-rouge">优先于微任务</code> 执行。</p>

:ET