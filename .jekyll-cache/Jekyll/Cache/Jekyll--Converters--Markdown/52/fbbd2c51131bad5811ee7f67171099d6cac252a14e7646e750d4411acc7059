I"K\<h3 id="1-promise含义">1. Promise含义</h3>
<p>Promise是一个对象，从它可以获取异步操作的消息。</p>

<p>简单说，是一个容器，存放着某个未来才会结束的事件（异步操作）的结果。</p>

<p>Promise提供统一API，所以异步操作都可以用同样方法进行处理。
<!--more-->
Promise对象特点：</p>

<ul>
  <li>一个Promise对象代表一个异步操作</li>
  <li>有三种状态：Pending、Fulfilled、Rejected</li>
  <li>状态由异步操作的结果决定，决定了不再变</li>
  <li>状态改变：Pending—–&gt;Fulfilled、Pending—–&gt;Rejected，保持着该结果称为Resolved</li>
  <li>如果改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果。（ps：Event，错过事件再监听则得不到结果）</li>
</ul>

<p>Promise缺点：</p>

<ul>
  <li>无法取消，一旦新建就会立即执行。</li>
  <li>Promise内部抛出的错误，不会反应到外部，除非设置回调函数。</li>
  <li>Pending状态无法定位哪一个阶段(刚开始还是要完成)。</li>
</ul>

<h3 id="2基本用法">2.基本用法</h3>

<p>（1）构造函数</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">异步操作成功</span><span class="p">)</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<blockquote>
  <p>resolve 函数作用：将Promise对象的状态Pending—–&gt;Resolved，在异步操作成功时调用，并将结果作为参数传递。</p>
</blockquote>

<blockquote>
  <p>reject 函数作用：Pending—–&gt;Rejected，异步操作失败时调用，将错误作为参数传递。</p>
</blockquote>

<p>（2）用then指定回调函数</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
        <span class="c1">//success</span>
    <span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
        <span class="c1">//failure</span>
<span class="p">});</span>
</code></pre></div></div>
<blockquote>
  <p>then接受两个回调函数作为参数，第一个是状态变为Resolved时调用，第二个是状态变为Rejected时调用，第二个可选。</p>
</blockquote>

<p>（3）执行顺序
promise新建后立即执行，then方法指定的回调函数在当前脚本所有同步任务执行完才会执行。</p>

<p>（4）参数
如果resolve函数和reject函数带参数，则会传递给回调函数。</p>

<p>reject函数的参数通常是Error对象的实例，表示抛出的错误。</p>

<p>resolve函数的参数可能是另一个Promise实例。如：p2的resolve方法将p1作为参数，这时p1的状态会传递给p2，如果p1的状态是Pending，则p2的回调函数就等待p1的状态改变，否则p2的回调函数立即执行。</p>

<h3 id="3promiseprototypethen-">3.Promise.prototype.then( )</h3>
<p>then方法是Promise的实例方法，定义在原型对象上。</p>

<p>作用：为Promise实例添加状态改变时的回调函数。</p>

<blockquote>
  <p>第一个参数是Resolved状态的回调函数，第二个（可选）是Rejected状态的回调参数。</p>
</blockquote>

<blockquote>
  <p>如果then方法返回的是一个新的Promise实例，可以链式写，直接在后面加 .then( )。第一个函数回调完成返回结果作为参数传给第二个函数。</p>
</blockquote>

<blockquote>
  <p>如果前一个回调函数返回的是一个Promise对象，则后一个会等待该Promise状态发生变化才会被调用。</p>
</blockquote>

<h3 id="4promiseprototypecatch-">4.Promise.prototype.catch( )</h3>
<p>是.then（null，rejection）的别名，用于指定发生错误时的回调函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getJSON</span><span class="p">(</span><span class="dl">'</span><span class="s1">/posts.json</span><span class="dl">'</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">){</span>
    <span class="p">...</span>	
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
    <span class="c1">//处理getJSON和前一个回调函数运行时发生的错误</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">发生错误！</span><span class="dl">'</span><span class="p">,</span>  <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<blockquote>
  <p>解析：getJSON方法返回一个Promise对象，如果对象状态变为Resolved，则调用then，如果异步操作抛出错误，状态就变为Rejected，就调用catch方法的回调函数，处理这个错误。</p>
</blockquote>

<h5 id="reject方法的作用等同于抛出错误">reject方法的作用，等同于抛出错误</h5>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">));</span>
<span class="p">});</span>
<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div></div>

<h5 id="如果promise状态已经变成resolved再抛出错误无效">如果Promise状态已经变成Resolved，再抛出错误无效。</h5>
<p>Promise对象的错误会‘冒泡’，直到被最后一个catch语句捕获。</p>

<p>尽量将.then的第二个参数用catch方法而不用reject函数，对比如下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="c1">//source</span>
<span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="c1">//error</span>
<span class="p">})</span>
    <span class="c1">//这种不好，用下面的表示方式：</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="c1">//source</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="c1">//error</span>
<span class="p">})</span>
</code></pre></div></div>

<p>如果没使用catch方法指定错误处理的回调函数，则Promise对象抛出的错误不会传递到外层。</p>

<p>后面的catch方法可以捕获前面的catch方法抛出的错误。</p>

<h3 id="5promiseall-">5.Promise.all( )</h3>
<p>将多个promise实例包装成一个新的promise实例。</p>

<p>每个成员都必须是promise，如果不是，则调用promise.resolve方法，将参数转为promise实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span><span class="nx">p2</span><span class="p">,</span><span class="nx">p3</span><span class="p">]);</span>  
</code></pre></div></div>

<blockquote>
  <p>解析：p的状态由p1、p2、p3决定。全部成员的状态都变成fulfilled，p的状态才变成fulfilled。只要一个成员的状态为rejected，p的状态就变为rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
</blockquote>

<blockquote>
  <p>两个实例的两个异步操作，只有等它们的状态结果都返回了，才会触发all里面的then的回调函数。</p>
</blockquote>

<blockquote>
  <p>如果作为参数的promise实例，自己定义了catch方法，那么它一旦被rejected，则不会触发all的catch方法。</p>
</blockquote>

<blockquote>
  <p>如果p2没有自己的catch方法，则会调用all的catch方法。</p>
</blockquote>

<h3 id="6promiserace-">6.Promise.race( )</h3>
<p>将多个Promise实例包装成一个新的Promise实例，这里我们设为p。</p>

<p>只要有一个实例改变状态，p的状态就跟着改变，率先改变的Promise实例的返回值传递给p的回调函数。</p>

<p>实例中如果不是promise实例，用Promise.resolve方法将参数转为Promise实例再处理。</p>

<h3 id="7promiseresolve-">7.Promise.resolve( )</h3>
<p>将对象转化为Promise对象。等价于</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">))</span>
</code></pre></div></div>

<p>参数分四种情况：</p>

<p>（1）参数是Promise实例，不用修改。</p>

<p>（2）参数是thenable对象（指具有then方法的对象），Promise.resolve方法将其转为Promsie对象，并立即执行thenable对象的then方法。</p>

<p>（3）参数不是具有then方法的对象，或不是对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。Resolved方法的参数会同时传递给回调函数。</p>

<p>（4）不带任何参数，直接返回一个Resolved状态的Promise对象，所以，直接调用Promise.resolve方法可以得到一个Promise对象。但是，得到的对象，是在本轮“事件循环”的结束时，而不是下一轮“事件循环”的开始。</p>

<h3 id="8promisereject-">8.Promise.reject( )</h3>
<p>Promise.reject( reason)方法返回一个新的Promise实例，状态为rejected。</p>

<p>Promise.reject( reason)方法的参数，原封不动地作为reject的理由。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">thenable</span><span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span> <span class="o">===</span> <span class="nx">thenable</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// true</span>
</code></pre></div></div>

<h3 id="9两个有用的附加方法">9.两个有用的附加方法</h3>
<p>（1）done( )
Promise对象的回调链最后一个方法抛出的错误可能无法捕捉到，所以done( )处于回调链的结尾。
（2）finally( )
不管Promise对象最后状态如何，都会执行的操作，接收一个必须执行的普通的回调函数作为参数。</p>

<h3 id="10promisetry-">10.Promise.try( )</h3>
<p>用一个统一的api来处理未知的同步或异步函数，让同步函数同步执行，异步函数异步执行。</p>

<p>所以如果想用then方法管理流程，最好都用Promise.try包装一下。</p>

<h4 id="搜集整理了一些promise的例子">搜集整理了一些Promise的例子</h4>
<ul>
  <li>三种状态的Promise</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
		<span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">},</span><span class="mi">500</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
		<span class="nx">reject</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">},</span><span class="mi">500</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">p2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<ul>
  <li>立即执行（异步代码异步执行）</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">异步代码</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">},</span><span class="mi">2000</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">create a promise</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">after new Promise</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>
<blockquote>
  <p>.then()是Promise实例状态发生改变时的回调函数。</p>
</blockquote>

<blockquote>
  <p>在创建new Promise对象时，作为参数传入的函数是会被立即执行的，只是可以是异步代码。</p>
</blockquote>

<p>下面看一个异步获取资源的实例：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">loadImg</span><span class="p">(</span><span class="nx">src</span><span class="p">){</span>
  <span class="kd">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">img</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">img</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">img</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">reject</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="nx">promise</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://a0.att.hudong.com/30/88/01100000000000144726882521407_s.jpg</span><span class="dl">'</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">loadImg</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">img</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">img</span><span class="p">.</span><span class="nx">width</span><span class="p">)</span>
<span class="p">},</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">img</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">img</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>总体使用方法如下：</p>

<blockquote>
  <p>new Promise 实例，传入带resolve和reject两个参数的函数，并且return</p>

  <p>成功时执行resolve()，失败时执行reject()</p>

  <p>.then( )监听结果</p>
</blockquote>

<hr />
<p>参考书籍 <a href="http://es6.ruanyifeng.com/">阮一峰的ES6标准入门</a></p>

:ET