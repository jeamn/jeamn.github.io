I"<p>JavaScript为函数对象定义了两个方法：apply和call，        <br />
它们的作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数的方式有所区别:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span><span class="nx">argArray</span><span class="p">);</span><span class="c1">//数组</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">[,</span><span class="nx">arg1</span><span class="p">[,</span><span class="nx">arg2</span><span class="p">...]]);</span><span class="c1">//多个参数</span>
</code></pre></div></div>

<p>从函数原型可以看到，第一个参数都被取名为thisArg，即所有函数内部的this指针都会被赋值为thisArg，这样做的目的是实现将函数作为另外一个对象的方法运行。
<!--more--></p>

<ul>
  <li>下面代码演示下：
定义一个函数func1，具有属性p和方法A</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func1</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">func1-</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">A</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">+</span> <span class="nx">arg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>定义一个函数func2,具有属性p和方法B</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func2</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">func2-</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">A</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">+</span> <span class="nx">arg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>然后创建实例</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">func1</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">func2</span><span class="p">();</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">A</span><span class="p">(</span><span class="dl">"</span><span class="s2">byA</span><span class="dl">"</span><span class="p">);</span>           <span class="c1">//显示func1-byA</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">B</span><span class="p">(</span><span class="dl">"</span><span class="s2">byB</span><span class="dl">"</span><span class="p">);</span>           <span class="c1">//显示func2-byB</span>

</code></pre></div></div>
<p>用apply和call时</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj1</span><span class="p">.</span><span class="nx">A</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj2</span><span class="p">,[</span><span class="dl">"</span><span class="s2">byA</span><span class="dl">"</span><span class="p">]);</span>   <span class="c1">//func2-byA</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">B</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj1</span><span class="p">,[</span><span class="dl">"</span><span class="s2">byB</span><span class="dl">"</span><span class="p">]);</span>   <span class="c1">//func1-byB</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj2</span><span class="p">,</span><span class="dl">"</span><span class="s2">byA</span><span class="dl">"</span><span class="p">);</span>      <span class="c1">//func2-byA</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">B</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj1</span><span class="p">,</span><span class="dl">"</span><span class="s2">byB</span><span class="dl">"</span><span class="p">);</span>      <span class="c1">//func1-byB</span>
</code></pre></div></div>

<p>可以看出，obj1的方法A被绑定到obj2运行后，整个函数A的运行环境就转移到了obj2，即this指针指向了obj2。同样obj2的函数B也可以绑定到obj1对象去运行。</p>

<p>简单来说，就是apply和call这两个关键字在运行时，能将运行环境进行转移。在继承和包装的时候回特别用到。</p>

<p>与argument的length属性不同，函数对象还有一个属性length，它表示函数定义时所指定参数的个数，而非调用时实际传递的参数个数。
利用这个性质可以判断函数中参数的个数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">sum</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>    <span class="c1">//2</span>
</code></pre></div></div>

<p>JS中出现同名函数时，后者会覆盖前者。</p>

:ET