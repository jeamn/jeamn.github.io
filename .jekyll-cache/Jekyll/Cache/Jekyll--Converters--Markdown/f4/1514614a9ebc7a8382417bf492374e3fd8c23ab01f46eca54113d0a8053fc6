I"8<h2 id="一理解-javascript-中的执行上下文和执行栈">一、理解 JavaScript 中的执行上下文和执行栈</h2>
<p>执行上下文：  <br />
是当前 js 代码被解析和执行时所在环境的抽象概念。它定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p>

<p>执行上下文三种类型： <br />
（1）全局执行上下文：一个，浏览器中是 window，this 指向这个全局对象； <br />
（2）函数执行上下文：无数个，只有在函数被调用的时候才会创建，每次调用都会创建一个新的执行上下文； <br />
（3）Eval 函数执行上下文：运行在 eval 函数中的代码。</p>

<p>执行栈也叫调用栈，具有后进先出结构，用于存储在代码执行期间创建的所有执行上下文。</p>

<p>首次运行 js 代码时，会创建一个全局执行上下文并 push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 push 到当前执行栈的栈顶。</p>

<p>运行完函数后，该函数执行上下文会从栈中 pop 出，上下文控制权将移到当前执行栈的下一个执行上下文。</p>

<h3 id="执行上下文的创建分两个阶段">执行上下文的创建分两个阶段：</h3>
<p>（1）创建阶段：</p>
<blockquote>
  <p>确定 this 的值，也称为 This Binding  <br />
词法环境组件被创建  <br />
变量环境组件被创建</p>
</blockquote>

<p>（2）执行阶段：完成对所有变量的分配，最后执行代码</p>

<h3 id="this-binding">This Binding：</h3>
<blockquote>
  <p>全局执行上下文中，this 的值指向全局对象，在浏览器中指向 window 对象，在 nodejs 中指向这个文件的 module 对象。   <br />
函数执行上下文中，this 的值取决于函数的调用方式，具体有：默认绑定、隐式绑定、显示绑定、new绑定、箭头函数</p>
</blockquote>

<h3 id="词法环境两个组成部分">词法环境两个组成部分：</h3>
<p>（1）环境记录：存储变量和函数声明的实际位置  <br />
（2）对外部环境的引用：可以访问其外部词法环境</p>

<h3 id="词法环境两种类型">词法环境两种类型：</h3>
<p>（1）全局环境：是一个没有外部环境的词法环境，其外部引用为 null。拥有一个全局对象（window）及其关联的方法和属性（如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。  <br />
（2）函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p>

<h3 id="变量环境">变量环境</h3>
<p>变量环境也是一种词法环境，因此具有词法环境的所有属性。  <br />
在 ES6 中，词法环境用于存储 <code class="highlighter-rouge">函数声明和变量（let、const）绑定</code>，变量环境用于存储 <code class="highlighter-rouge">变量（var）绑定</code>。</p>

<h3 id="变量提升原因">变量提升原因</h3>
<p>在执行上下文创建阶段，函数声明存储在环境中，而 var 定义的变量会被设置为 undefined 。</p>

<h2 id="二四种常见的内存泄漏">二、四种常见的内存泄漏</h2>
<h3 id="1意外的全局变量">1、意外的全局变量</h3>
<p>函数内部未用 var 定义变量，或者函数内部使用了 this 赋值了变量。  <br />
解决方法：在 js 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时 this 会指向 undefined。</p>

<h3 id="2被遗忘的计时器或回调函数">2、被遗忘的计时器或回调函数</h3>
<p>未结束的定时器未赋值为 null</p>

<h3 id="3闭包">3、闭包</h3>

<h2 id="三闭包">三、闭包</h2>
<h3 id="1概念">1、概念</h3>
<p>闭包是指有权限访问另外一个函数作用域中的变量的函数。</p>

<p>当函数返回没有被引用的时候，就会被垃圾回收器回收。但是对于闭包，即使外部函数返回了，函数对象仍会引用它被创建时的作用域对象。</p>

<h3 id="2闭包特性">2、闭包特性</h3>
<p>（1）可以访问当前函数以外的变量</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fa</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kd">function</span> <span class="nx">fb</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fb</span><span class="p">()</span>
<span class="p">}</span>
<span class="nx">fa</span><span class="p">()</span>
</code></pre></div></div>

<p>（2）即使外部函数已经返回，闭包仍能访问外部函数定义的变量</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fa</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kd">function</span> <span class="nx">fb</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fb</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">fc</span> <span class="o">=</span> <span class="nx">fa</span><span class="p">()</span>
<span class="nx">fc</span><span class="p">()</span>
</code></pre></div></div>

<p>（3）闭包可以更新外部变量的值</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fa</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kd">function</span> <span class="nx">fb</span><span class="p">(){</span>
        <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fb</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">fc</span> <span class="o">=</span> <span class="nx">fa</span><span class="p">()</span>
<span class="nx">fc</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="3作用域链和原型链">3、作用域链和原型链</h3>
<p>作用域链：当访问一个变量时，解释器会首先在当前作用域查找标识符，如果没找到会去父作用域找，直到找到该变量的标识符或者不在父作用域中，这就是作用域链。</p>

<p>原型链：在 JavaScript 中，一共有两种类型的值，原始值和对象值。每个对象都有一个内部属性[[prototype]]，我们通常称之为原型。原型的值可以是一个对象，也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，称之为原型链（比如我们新建一个数组，数组的方法就是从数组的原型上继承而来的）。</p>

<p>两者区别： <br />
一般来说，作用域链是针对变量的，js里面大的范围上来说，只有两种作用域，全局作用域和函数内部作用域，如果函数1里面又定义了函数2（一般都是匿名函数）， 那么就有了这么一个作用域链全局作用域==&gt;函数1作用域==&gt;函数2作用域；特点是函数1里面可以直接使用全局作用域的变量，函数2里面可以直接使用全局作用域和函数1作用域的变量。  <br />
而原型链的话，一般是定义构造函数时用到。可以认为是针对构造函数的或者说针对构造函数对应的类的。原型链的头部就是Object类/构造函数，如果有构造函数1.prototype = 构造函数2；那么也就有这么一个原型链； Object ==&gt; 构造函数1 ==&gt; 构造函数2，这样的好处是构造函数2对应的类，可以拥有构造函数1 和Object中的属性，js没有对应继承的关键字，所以用原型链来模拟继承的效果。</p>

<p>两者在查找时的区别：  <br />
如果去查找一个普通对象的属性，但是在当前对象和原型上都找不到时，会返回 undefined，</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">mike</span><span class="dl">'</span>
<span class="kd">function</span> <span class="nx">Dog</span><span class="p">(</span><span class="nx">dogName</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dogName</span> <span class="o">=</span> <span class="nx">dogName</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//继承</span>
<span class="nx">Dog</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dog</span><span class="p">(</span><span class="dl">'</span><span class="s1">泰迪</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">dog1</span><span class="p">.</span><span class="nx">name1</span><span class="p">)</span>
</code></pre></div></div>

<p>但查找的属性在作用域链中不存在的话就会抛出 ReferenceError。</p>

<p>作用域链的顶端是全局对象，在全局环境中定义的变量会绑定到全局对象中。  <br />
原型链的顶端是 null。</p>

<h3 id="4闭包与作用域链">4、闭包与作用域链</h3>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">global scope</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">checkscope</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">local scope</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
        <span class="k">return</span> <span class="nx">scope</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">checkscope</span><span class="p">();</span> <span class="c1">// foo指向函数f</span>
<span class="nx">foo</span><span class="p">();</span>					<span class="c1">// 调用函数f()</span>
</code></pre></div></div>

<p>执行过程如下：
1、进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；  <br />
2、全局执行上下文初始化；   <br />
3、执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈；  <br />
4、checkscope 执行上下文初始化，创建变量对象、作用域链、this 等；  <br />
5、checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出；  <br />
6、执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；  <br />
7、f 执行上下文初始化，创建变量对象、作用域链、this 等；  <br />
8、f 函数执行完毕，f 函数执行上下文从执行上下文栈中弹出；</p>

<p>当函数 f 执行的时候，checkscope 函数的执行上下文已经被销毁，那么函数 f 是如何获取到 scope 变量的？</p>

<p>解释：函数 f 执行上下文维护了一个作用域链，会指向 checkscope 的作用域，作用域链是一个数组，子函数会保存它所有的父级作用域，指向关系为：当前作用域 -&gt; 父作用域 -&gt; 祖父作用域 -&gt; ··· -&gt; 全局作用域。所以 f 函数维护着 checkscope 的作用域，才能访问到变量 scope。</p>

<p>这就是闭包实现的关键：通过函数的作用域链找到自由变量。</p>

<p>总结：从理论上，所有的函数都是闭包，因为他们都在创建的时候就将上层执行上下文的数据保存起来了。普通函数在访问全局变量就相当于是在访问自由变量。而从实践的角度，以下函数才算是闭包：即使创建函数的上下文已经销毁，它仍然存在（比如内部函数从父函数中返回）；或者在代码中引用了自由变量。</p>
:ET